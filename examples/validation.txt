wKrQ Literature Validation Test Suite
================================================================================
This output validates the implementation against literature test cases.
Each test shows the command run and its complete output including tableau trees.
Generated by: /Users/bradleyallen/Documents/GitHub/wkrq/examples/literature_validation.py

================================================================================
 wKrQ Tableau Rules (All Rules Demonstrated)
================================================================================

------------------------------------------------------------
Test: T-Conjunction Rule: T:(A & B) produces T:A and T:B
Command: wkrq --sign=T --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p & q
    ├──  1. T: p [T-Conjunction: 0]
    └──  2. T: q [T-Conjunction: 0]


------------------------------------------------------------
Test: F-Disjunction Rule: F:(A | B) produces F:A and F:B
Command: wkrq --sign=F --tree --show-rules p | q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: p | q
    ├──  1. F: p [F-Disjunction: 0]
    └──  2. F: q [F-Disjunction: 0]


------------------------------------------------------------
Test: T-Negation Rule: T:~A produces F:A
Command: wkrq --sign=T --tree --show-rules ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: ~p
    └──  1. F: p [T-Negation: 0]


------------------------------------------------------------
Test: F-Negation Rule: F:~A produces T:A
Command: wkrq --sign=F --tree --show-rules ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: ~p
    └──  1. T: p [F-Negation: 0]


------------------------------------------------------------
Test: N-Conjunction Rule: N:(A & B) produces N:A and N:B
Command: wkrq --sign=N --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: p & q
    ├──  1. N: p [N-Conjunction: 0]
    └──  2. N: q [N-Conjunction: 0]


------------------------------------------------------------
Test: N-Disjunction Rule: N:(A | B) produces N:A and N:B
Command: wkrq --sign=N --tree --show-rules p | q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: p | q
    ├──  1. N: p [N-Disjunction: 0]
    └──  2. N: q [N-Disjunction: 0]


------------------------------------------------------------
Test: N-Implication Rule: N:(A -> B) produces N:A and N:B
Command: wkrq --sign=N --tree --show-rules p -> q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: p -> q
    ├──  1. N: p  [N-Implication: 0]
    └──  2. N: q  [N-Implication: 0]


------------------------------------------------------------
Test: N-Negation Rule: N:~A produces N:A
Command: wkrq --sign=N --tree --show-rules ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: ~p
    └──  1. N: p [N-Negation: 0]


------------------------------------------------------------
Test: T-Disjunction Rule: T:(A | B) branches to T:A or T:B
Command: wkrq --sign=T --tree --show-rules p | q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p | q
    ├──  1. T: p [T-Disjunction: 0]
    └──  2. T: q [T-Disjunction: 0]


------------------------------------------------------------
Test: F-Conjunction Rule: F:(A & B) branches to F:A or F:B
Command: wkrq --sign=F --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: p & q
    ├──  1. F: p [F-Conjunction: 0]
    └──  2. F: q [F-Conjunction: 0]


------------------------------------------------------------
Test: T-Implication Rule: T:(A -> B) branches to F:A or T:B
Command: wkrq --sign=T --tree --show-rules p -> q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p -> q
    ├──  1. F: p  [T-Implication: 0]
    └──  2. T: q  [T-Implication: 0]


------------------------------------------------------------
Test: F-Implication Rule: F:(A -> B) produces T:A and F:B
Command: wkrq --sign=F --tree --show-rules p -> q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: p -> q
    ├──  1. T: p  [F-Implication: 0]
    └──  2. F: q  [F-Implication: 0]


------------------------------------------------------------
Test: M-Propositional Rule: M:p branches to T:p or F:p
Command: wkrq --sign=M --tree --show-rules p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. M: p


------------------------------------------------------------
Test: M-Compound Rule: M:(A & B) branches to M:A and M:B
Command: wkrq --sign=M --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. M: p & q
    ├──  1. M: p [M-Conjunction: 0]
    └──  2. M: q [M-Conjunction: 0]


------------------------------------------------------------
Test: T-Universal Rule: T:[∀X P(X)]Q(X) branches to F:P(c) or T:Q(c)
Command: wkrq --sign=T --tree --show-rules [forall X Human(X)]Mortal(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∀X Human(X)]Mortal(X)
    ├──  1. F: Human(c_1)         [T-RestrictedForall: 0]
    └──  2. T: Mortal(c_1)        [T-RestrictedForall: 0]


------------------------------------------------------------
Test: T-Existential Rule: T:[∃X P(X)]Q(X) produces T:P(c) and T:Q(c)
Command: wkrq --sign=T --tree --show-rules [exists X Student(X)]Smart(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∃X Student(X)]Smart(X)
    ├──  1. T: Student(c_1)        [T-RestrictedExists: 0]
    └──  2. T: Smart(c_1)          [T-RestrictedExists: 0]


------------------------------------------------------------
Test: F-Universal Rule: F:[∀X P(X)]Q(X) produces T:P(c) and F:Q(c)
Command: wkrq --sign=F --tree --show-rules [forall X Human(X)]Mortal(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: [∀X Human(X)]Mortal(X)
    ├──  1. T: Human(c_1)         [F-RestrictedForall: 0]
    └──  2. F: Mortal(c_1)        [F-RestrictedForall: 0]


------------------------------------------------------------
Test: F-Existential Rule: F:[∃X P(X)]Q(X) branches to F:P(c) or F:Q(c)
Command: wkrq --sign=F --tree --show-rules [exists X Student(X)]Smart(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: [∃X Student(X)]Smart(X)
    ├──  1. F: Student(c_1)        [F-RestrictedExists: 0]
    └──  2. F: Smart(c_1)          [F-RestrictedExists: 0]


================================================================================
 ACrQ Bilateral Predicate Rules (Paraconsistent Extension)
================================================================================

------------------------------------------------------------
Test: ACrQ T-Positive Predicate: T:R(a) produces T:R(a) (no R* interaction)
Command: wkrq --mode=acrq --sign=T --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice)
    └──  1. T: Human(alice) [T-R: 0]


------------------------------------------------------------
Test: ACrQ T-Negative Predicate: T:R*(a) produces T:R*(a) (no R interaction)
Command: wkrq --mode=acrq --syntax=bilateral --sign=T --tree --show-rules Human*(alice)
------------------------------------------------------------
ACrQ Formula (bilateral mode): Human*(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human*(alice)
    └──  1. T: Human*(alice) [T-R*: 0]


------------------------------------------------------------
Test: ACrQ F-Positive Predicate: F:R(a) produces F:R(a)
Command: wkrq --mode=acrq --sign=F --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: F
Satisfiable: True

Tableau tree:
 0. F: Human(alice)
    └──  1. F: Human(alice) [F-R: 0]


------------------------------------------------------------
Test: ACrQ F-Negative Predicate: F:R*(a) produces F:R*(a)
Command: wkrq --mode=acrq --syntax=bilateral --sign=F --tree --show-rules Human*(alice)
------------------------------------------------------------
ACrQ Formula (bilateral mode): Human*(alice)
Sign: F
Satisfiable: True

Tableau tree:
 0. F: Human*(alice)
    └──  1. F: Human*(alice) [F-R*: 0]


------------------------------------------------------------
Test: ACrQ N-Predicate: N:R(a) produces F:R(a) and F:R*(a) (knowledge gap)
Command: wkrq --mode=acrq --sign=N --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: N
Satisfiable: True

Tableau tree:
 0. N: Human(alice)
    ├──  1. F: Human(alice)  [N-R: 0]
    └──  2. F: Human*(alice) [N-R: 0]


------------------------------------------------------------
Test: ACrQ M-Predicate: M:R(a) branches to T:R(a) or F:R(a)
Command: wkrq --mode=acrq --sign=M --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: M
Satisfiable: True

Tableau tree:
 0. M: Human(alice)
    ├──  1. T: Human(alice) [M-R: 0]
    └──  2. F: Human(alice) [M-R: 0]


------------------------------------------------------------
Test: ACrQ Transparent Negation: ~R(a) becomes R*(a)
Command: wkrq --mode=acrq --syntax=transparent --sign=T --tree --show-rules ~Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human*(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human*(alice)
    └──  1. T: Human*(alice) [T-R*: 0]


------------------------------------------------------------
Test: ACrQ Knowledge Glut: R(a) & R*(a) is satisfiable (paraconsistent)
Command: wkrq --mode=acrq --syntax=transparent --sign=T --tree --show-rules Human(alice) & ~Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice) & Human*(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice) & Human*(alice)
    ├──  1. T: Human(alice)             [T-Conjunction: 0]
    │   └──  3. T: Human(alice)         [T-R: 1]
    └──  2. T: Human*(alice)            [T-Conjunction: 0]
        └──  4. T: Human*(alice)        [T-R*: 2]


------------------------------------------------------------
Test: ACrQ Compound with Bilateral: (R(a) | S*(b)) & T(c)
Command: wkrq --mode=acrq --syntax=mixed --sign=T --tree --show-rules (Human(alice) | Robot*(bob)) & Alien(charlie)
------------------------------------------------------------
ACrQ Formula (mixed mode): (Human(alice) | Robot*(bob)) & Alien(charlie)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: (Human(alice) | Robot*(bob)) & Alien(charlie)
    ├──  1. T: Human(alice) | Robot*(bob)                [T-Conjunction: 0]
    │   ├──  4. T: Human(alice)                          [T-Disjunction: 1]
    │   │   └──  6. T: Human(alice)                      [T-R: 4]
    │   └──  5. T: Robot*(bob)                           [T-Disjunction: 1]
    │       └──  7. T: Robot*(bob)                       [T-R*: 5]
    └──  2. T: Alien(charlie)                            [T-Conjunction: 0]
        └──  3. T: Alien(charlie)                        [T-R: 2]


------------------------------------------------------------
Test: ACrQ No Explosion: Contradiction doesn't entail arbitrary formula
Command: wkrq --mode=acrq --inference --tree --show-rules Human(alice), ~Human(alice) |- Robot(bob)
------------------------------------------------------------
ACrQ Inference (transparent mode):
  Premises: Human(alice), Human*(alice)
  Conclusion: Robot(bob)
  ✗ Invalid inference
  Countermodels:
    1. {Human(alice)=t, Human*(alice)=t, Robot(bob)=f}

Tableau tree:
 0. T: Human(alice)
    ├──  1. T: Human*(alice)
    │   └──  4. T: Human*(alice) [T-R*: 1]
    ├──  2. F: Robot(bob)
    │   └──  5. F: Robot(bob)    [F-R: 2]
    └──  3. T: Human(alice)      [T-R: 0]


================================================================================
 Unsatisfiable Cases with Different Signs
================================================================================

------------------------------------------------------------
Test: Tautology cannot be false (F-sign unsatisfiable)
Command: wkrq --sign=F --tree --show-rules p | ~p
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. F: p | (~p)
    ├──  1. F: p  ×     [F-Disjunction: 0]
    └──  2. F: ~p       [F-Disjunction: 0]
        └──  3. T: p  × [F-Negation: 2]


------------------------------------------------------------
Test: Contradiction cannot be true (T-sign unsatisfiable)
Command: wkrq --sign=T --tree --show-rules p & ~p
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: p & (~p)
    ├──  1. T: p  ×     [T-Conjunction: 0]
    └──  2. T: ~p       [T-Conjunction: 0]
        └──  3. F: p  × [T-Negation: 2]


------------------------------------------------------------
Test: Double negation elimination failure
Command: wkrq --sign=F --tree --show-rules p -> ~~p
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. F: p -> (~(~p))
    ├──  1. T: p  ×         [F-Implication: 0]
    └──  2. F: ~(~p)        [F-Implication: 0]
        └──  3. T: ~p       [F-Negation: 2]
            └──  4. F: p  × [T-Negation: 3]


------------------------------------------------------------
Test: Law of excluded middle cannot be false
Command: wkrq --sign=F --tree --show-rules (p -> q) | (p -> ~q)
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. F: (p -> q) | (p -> (~q))
    ├──  1. F: p -> q             [F-Disjunction: 0]
    │   ├──  3. T: p  ×           [F-Implication: 1]
    │   └──  4. F: q  ×           [F-Implication: 1]
    └──  2. F: p -> (~q)          [F-Disjunction: 0]
        └──  5. F: ~q             [F-Implication: 2]
            └──  6. T: q  ×       [F-Negation: 5]


------------------------------------------------------------
Test: Pierce's law cannot be undefined
Command: wkrq --sign=N --tree --show-rules ((p -> q) -> p) -> p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: ((p -> q) -> p) -> p
    ├──  1. N: (p -> q) -> p    [N-Implication: 0]
    └──  2. N: p                [N-Implication: 0]


================================================================================
 Epistemic vs Truth-Functional Distinction
================================================================================

------------------------------------------------------------
Test: Truth-functional contradiction (unsatisfiable)
Command: wkrq --sign=T --tree --show-rules p & ~p
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: p & (~p)
    ├──  1. T: p  ×     [T-Conjunction: 0]
    └──  2. T: ~p       [T-Conjunction: 0]
        └──  3. F: p  × [T-Negation: 2]


------------------------------------------------------------
Test: Epistemic uncertainty about contradiction (satisfiable)
Command: wkrq --sign=M --tree --show-rules p & ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. M: p & (~p)
    ├──  1. M: p    [M-Conjunction: 0]
    └──  2. M: ~p   [M-Conjunction: 0]


------------------------------------------------------------
Test: Contradiction can be undefined (satisfiable)
Command: wkrq --sign=N --tree --show-rules p & ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. N: p & (~p)
    ├──  1. N: p    [N-Conjunction: 0]
    └──  2. N: ~p   [N-Conjunction: 0]


================================================================================
 Smullyan Alpha Rules (Non-branching)
================================================================================

------------------------------------------------------------
Test: T-Conjunction (alpha rule)
Command: wkrq --sign=T --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p & q
    ├──  1. T: p [T-Conjunction: 0]
    └──  2. T: q [T-Conjunction: 0]


------------------------------------------------------------
Test: F-Disjunction (alpha rule)
Command: wkrq --sign=F --tree --show-rules p | q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: p | q
    ├──  1. F: p [F-Disjunction: 0]
    └──  2. F: q [F-Disjunction: 0]


------------------------------------------------------------
Test: T-Negation (alpha rule)
Command: wkrq --sign=T --tree --show-rules ~p
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: ~p
    └──  1. F: p [T-Negation: 0]


================================================================================
 Smullyan Beta Rules (Branching)
================================================================================

------------------------------------------------------------
Test: T-Disjunction (beta rule - should branch)
Command: wkrq --sign=T --tree --show-rules p | q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p | q
    ├──  1. T: p [T-Disjunction: 0]
    └──  2. T: q [T-Disjunction: 0]


------------------------------------------------------------
Test: F-Conjunction (beta rule - should branch)
Command: wkrq --sign=F --tree --show-rules p & q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. F: p & q
    ├──  1. F: p [F-Conjunction: 0]
    └──  2. F: q [F-Conjunction: 0]


------------------------------------------------------------
Test: T-Implication (beta rule - should branch)
Command: wkrq --sign=T --tree --show-rules p -> q
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: p -> q
    ├──  1. F: p  [T-Implication: 0]
    └──  2. T: q  [T-Implication: 0]


================================================================================
 Classical Valid Inferences
================================================================================

------------------------------------------------------------
Test: Modus Ponens
Command: wkrq --inference --tree --show-rules p, p -> q |- q
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (p & (p -> q)) & (~q)
    ├──  1. T: p & (p -> q)      [T-Conjunction: 0]
    │   ├──  4. T: p  ×          [T-Conjunction: 1]
    │   └──  5. T: p -> q        [T-Conjunction: 1]
    │       ├──  6. F: p  ×      [T-Implication: 5]
    │       └──  7. T: q  ×      [T-Implication: 5]
    └──  2. T: ~q                [T-Conjunction: 0]
        └──  3. F: q  ×          [T-Negation: 2]


------------------------------------------------------------
Test: Modus Tollens
Command: wkrq --inference --tree --show-rules p -> q, ~q |- ~p
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: ((p -> q) & (~q)) & (~(~p))
    ├──  1. T: (p -> q) & (~q)         [T-Conjunction: 0]
    │   ├──  5. T: p -> q              [T-Conjunction: 1]
    │   │   ├──  8. F: p  ×            [T-Implication: 5]
    │   │   └──  9. T: q  ×            [T-Implication: 5]
    │   └──  6. T: ~q                  [T-Conjunction: 1]
    │       └──  7. F: q  ×            [T-Negation: 6]
    └──  2. T: ~(~p)                   [T-Conjunction: 0]
        └──  3. F: ~p                  [T-Negation: 2]
            └──  4. T: p  ×            [F-Negation: 3]


------------------------------------------------------------
Test: Hypothetical Syllogism
Command: wkrq --inference --tree --show-rules p -> q, q -> r |- p -> r
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: ((p -> q) & (q -> r)) & (~(p -> r))
    ├──  1. T: (p -> q) & (q -> r)             [T-Conjunction: 0]
    │   ├──  4. T: p -> q                      [T-Conjunction: 1]
    │   │   ├──  8. F: p  ×                    [T-Implication: 4]
    │   │   └──  9. T: q  ×                    [T-Implication: 4]
    │   └──  5. T: q -> r                      [T-Conjunction: 1]
    │       ├── 10. F: q  ×                    [T-Implication: 5]
    │       └── 11. T: r  ×                    [T-Implication: 5]
    └──  2. T: ~(p -> r)                       [T-Conjunction: 0]
        └──  3. F: p -> r                      [T-Negation: 2]
            ├──  6. T: p  ×                    [F-Implication: 3]
            └──  7. F: r  ×                    [F-Implication: 3]


------------------------------------------------------------
Test: Disjunctive Syllogism
Command: wkrq --inference --tree --show-rules p | q, ~p |- q
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: ((p | q) & (~p)) & (~q)
    ├──  1. T: (p | q) & (~p)      [T-Conjunction: 0]
    │   ├──  4. T: p | q           [T-Conjunction: 1]
    │   │   ├──  7. T: p  ×        [T-Disjunction: 4]
    │   │   └──  8. T: q  ×        [T-Disjunction: 4]
    │   └──  5. T: ~p              [T-Conjunction: 1]
    │       └──  6. F: p  ×        [T-Negation: 5]
    └──  2. T: ~q                  [T-Conjunction: 0]
        └──  3. F: q  ×            [T-Negation: 2]


================================================================================
 Classical Invalid Inferences (Should Show Countermodels)
================================================================================

------------------------------------------------------------
Test: Affirming the Consequent (invalid)
Command: wkrq --inference --countermodel --show-rules p -> q, q |- p
------------------------------------------------------------
✗ Invalid inference
Countermodels:
  1. {p=f, q=t}
  2. {p=f, q=t}


------------------------------------------------------------
Test: Denying the Antecedent (invalid)
Command: wkrq --inference --countermodel --show-rules p -> q, ~p |- ~q
------------------------------------------------------------
✗ Invalid inference
Countermodels:
  1. {p=f, q=t}
  2. {p=f, q=t}


================================================================================
 Additional Valid Inferences (Complex Closed Branch Patterns)
================================================================================

------------------------------------------------------------
Test: Contradiction in premises
Command: wkrq --inference --tree --show-rules p, ~p |- q
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (p & (~p)) & (~q)
    ├──  1. T: p & (~p)      [T-Conjunction: 0]
    │   ├──  4. T: p  ×      [T-Conjunction: 1]
    │   └──  5. T: ~p        [T-Conjunction: 1]
    │       └──  6. F: p  ×  [T-Negation: 5]
    └──  2. T: ~q            [T-Conjunction: 0]
        └──  3. F: q  ×      [T-Negation: 2]


------------------------------------------------------------
Test: Complex tautology inference
Command: wkrq --inference --tree --show-rules p -> q, q -> r, r -> s |- p -> s
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (((p -> q) & (q -> r)) & (r -> s)) & (~(p -> s))
    ├──  1. T: ((p -> q) & (q -> r)) & (r -> s)             [T-Conjunction: 0]
    │   ├──  4. T: (p -> q) & (q -> r)                      [T-Conjunction: 1]
    │   │   ├──  6. T: p -> q                               [T-Conjunction: 4]
    │   │   │   ├── 12. F: p  ×                             [T-Implication: 6]
    │   │   │   └── 13. T: q  ×                             [T-Implication: 6]
    │   │   └──  7. T: q -> r                               [T-Conjunction: 4]
    │   │       ├── 14. F: q  ×                             [T-Implication: 7]
    │   │       └── 15. T: r  ×                             [T-Implication: 7]
    │   └──  5. T: r -> s                                   [T-Conjunction: 1]
    │       ├── 10. F: r  ×                                 [T-Implication: 5]
    │       └── 11. T: s  ×                                 [T-Implication: 5]
    └──  2. T: ~(p -> s)                                    [T-Conjunction: 0]
        └──  3. F: p -> s                                   [T-Negation: 2]
            ├──  8. T: p  ×                                 [F-Implication: 3]
            └──  9. F: s  ×                                 [F-Implication: 3]


------------------------------------------------------------
Test: Disjunction elimination
Command: wkrq --inference --tree --show-rules p | q, p -> r, q -> r |- r
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (((p | q) & (p -> r)) & (q -> r)) & (~r)
    ├──  1. T: ((p | q) & (p -> r)) & (q -> r)      [T-Conjunction: 0]
    │   ├──  4. T: (p | q) & (p -> r)               [T-Conjunction: 1]
    │   │   ├──  6. T: p | q                        [T-Conjunction: 4]
    │   │   │   ├──  8. T: p  ×                     [T-Disjunction: 6]
    │   │   │   └──  9. T: q  ×                     [T-Disjunction: 6]
    │   │   └──  7. T: p -> r                       [T-Conjunction: 4]
    │   │       ├── 14. F: p  ×                     [T-Implication: 7]
    │   │       └── 15. T: r  ×                     [T-Implication: 7]
    │   └──  5. T: q -> r                           [T-Conjunction: 1]
    │       ├── 10. F: q  ×                         [T-Implication: 5]
    │       ├── 11. T: r  ×                         [T-Implication: 5]
    │       ├── 12. F: q  ×                         [T-Implication: 5]
    │       └── 13. T: r  ×                         [T-Implication: 5]
    └──  2. T: ~r                                   [T-Conjunction: 0]
        └──  3. F: r  ×                             [T-Negation: 2]


------------------------------------------------------------
Test: Proof by cases
Command: wkrq --inference --tree --show-rules p | ~p, p -> q, ~p -> q |- q
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (((p | (~p)) & (p -> q)) & ((~p) -> q)) & (~q)
    ├──  1. T: ((p | (~p)) & (p -> q)) & ((~p) -> q)      [T-Conjunction: 0]
    │   ├──  4. T: (p | (~p)) & (p -> q)                  [T-Conjunction: 1]
    │   │   ├──  6. T: p | (~p)                           [T-Conjunction: 4]
    │   │   │   ├──  8. T: p  ×                           [T-Disjunction: 6]
    │   │   │   └──  9. T: ~p                             [T-Disjunction: 6]
    │   │   │       └── 12. F: p  ×                       [T-Negation: 9]
    │   │   └──  7. T: p -> q                             [T-Conjunction: 4]
    │   │       ├── 15. F: p  ×                           [T-Implication: 7]
    │   │       └── 16. T: q  ×                           [T-Implication: 7]
    │   └──  5. T: (~p) -> q                              [T-Conjunction: 1]
    │       ├── 10. F: ~p  ×                              [T-Implication: 5]
    │       ├── 11. T: q  ×                               [T-Implication: 5]
    │       ├── 13. F: ~p  ×                              [T-Implication: 5]
    │       └── 14. T: q  ×                               [T-Implication: 5]
    └──  2. T: ~q                                         [T-Conjunction: 0]
        └──  3. F: q  ×                                   [T-Negation: 2]


------------------------------------------------------------
Test: Constructive dilemma
Command: wkrq --inference --tree --show-rules (p -> q) & (r -> s), p | r |- q | s
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (((p -> q) & (r -> s)) & (p | r)) & (~(q | s))
    ├──  1. T: ((p -> q) & (r -> s)) & (p | r)            [T-Conjunction: 0]
    │   ├──  4. T: (p -> q) & (r -> s)                    [T-Conjunction: 1]
    │   │   ├──  6. T: p -> q                             [T-Conjunction: 4]
    │   │   │   ├── 12. F: p  ×                           [T-Implication: 6]
    │   │   │   ├── 13. T: q  ×                           [T-Implication: 6]
    │   │   │   ├── 14. F: p  ×                           [T-Implication: 6]
    │   │   │   └── 15. T: q  ×                           [T-Implication: 6]
    │   │   └──  7. T: r -> s                             [T-Conjunction: 4]
    │   │       ├── 16. F: r  ×                           [T-Implication: 7]
    │   │       └── 17. T: s  ×                           [T-Implication: 7]
    │   └──  5. T: p | r                                  [T-Conjunction: 1]
    │       ├── 10. T: p  ×                               [T-Disjunction: 5]
    │       └── 11. T: r  ×                               [T-Disjunction: 5]
    └──  2. T: ~(q | s)                                   [T-Conjunction: 0]
        └──  3. F: q | s                                  [T-Negation: 2]
            ├──  8. F: q  ×                               [F-Disjunction: 3]
            └──  9. F: s  ×                               [F-Disjunction: 3]


------------------------------------------------------------
Test: Quantifier inference with closure
Command: wkrq --inference --tree --show-rules [forall X Human(X)]Mortal(X), [forall Y Mortal(Y)]Dies(Y), Human(socrates) |- Dies(socrates)
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: (([∀X Human(X)]Mortal(X) & [∀Y Mortal(Y)]Dies(Y)) & Human(socrates)) & (~Dies(socrates))
    ├──  1. T: ([∀X Human(X)]Mortal(X) & [∀Y Mortal(Y)]Dies(Y)) & Human(socrates)                   [T-Conjunction: 0]
    │   ├──  4. T: [∀X Human(X)]Mortal(X) & [∀Y Mortal(Y)]Dies(Y)                                   [T-Conjunction: 1]
    │   │   ├──  6. T: [∀X Human(X)]Mortal(X)                                                       [T-Conjunction: 4]
    │   │   │   ├──  8. F: Human(socrates)  ×                                                       [T-RestrictedForall: 6]
    │   │   │   └──  9. T: Mortal(socrates)  ×                                                      [T-RestrictedForall: 6]
    │   │   └──  7. T: [∀Y Mortal(Y)]Dies(Y)                                                        [T-Conjunction: 4]
    │   │       ├── 10. F: Mortal(socrates)  ×                                                      [T-RestrictedForall: 7]
    │   │       └── 11. T: Dies(socrates)  ×                                                        [T-RestrictedForall: 7]
    │   └──  5. T: Human(socrates)  ×                                                               [T-Conjunction: 1]
    └──  2. T: ~Dies(socrates)                                                                      [T-Conjunction: 0]
        └──  3. F: Dies(socrates)  ×                                                                [T-Negation: 2]


================================================================================
 First-Order Logic with Restricted Quantifiers
================================================================================

------------------------------------------------------------
Test: Universal quantifier with ASCII syntax
Command: wkrq --tree --show-rules [forall X Human(X)]Mortal(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∀X Human(X)]Mortal(X)
    ├──  1. F: Human(c_1)         [T-RestrictedForall: 0]
    └──  2. T: Mortal(c_1)        [T-RestrictedForall: 0]


------------------------------------------------------------
Test: Existential quantifier with ASCII syntax
Command: wkrq --tree --show-rules [exists X Student(X)]Human(X)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∃X Student(X)]Human(X)
    ├──  1. T: Student(c_1)        [T-RestrictedExists: 0]
    └──  2. T: Human(c_1)          [T-RestrictedExists: 0]


------------------------------------------------------------
Test: Valid universal inference
Command: wkrq --inference --tree --show-rules [forall X Human(X)]Mortal(X), Human(socrates) |- Mortal(socrates)
------------------------------------------------------------
✓ Valid inference

Tableau tree:
 0. T: ([∀X Human(X)]Mortal(X) & Human(socrates)) & (~Mortal(socrates))
    ├──  1. T: [∀X Human(X)]Mortal(X) & Human(socrates)                     [T-Conjunction: 0]
    │   ├──  4. T: [∀X Human(X)]Mortal(X)                                   [T-Conjunction: 1]
    │   │   ├──  6. F: Human(socrates)  ×                                   [T-RestrictedForall: 4]
    │   │   └──  7. T: Mortal(socrates)  ×                                  [T-RestrictedForall: 4]
    │   └──  5. T: Human(socrates)  ×                                       [T-Conjunction: 1]
    └──  2. T: ~Mortal(socrates)                                            [T-Conjunction: 0]
        └──  3. F: Mortal(socrates)  ×                                      [T-Negation: 2]


================================================================================
 Complex First-Order Examples
================================================================================

------------------------------------------------------------
Test: Multiple quantifiers
Command: wkrq --tree --show-rules [forall X Human(X)]Mortal(X) & [exists Y Student(Y)]Smart(Y)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∀X Human(X)]Mortal(X) & [∃Y Student(Y)]Smart(Y)
    ├──  1. T: [∀X Human(X)]Mortal(X)                       [T-Conjunction: 0]
    │   ├──  5. F: Human(c_3)                               [T-RestrictedForall: 1]
    │   └──  6. T: Mortal(c_3)                              [T-RestrictedForall: 1]
    └──  2. T: [∃Y Student(Y)]Smart(Y)                      [T-Conjunction: 0]
        ├──  3. T: Student(c_3)                             [T-RestrictedExists: 2]
        └──  4. T: Smart(c_3)                               [T-RestrictedExists: 2]


------------------------------------------------------------
Test: Medical inference with complex parsing
Command: wkrq --inference --tree --show-rules [forall X [exists Y (beneficial(X,Y) & has_condition(Y,X))]]prescribed(X), beneficial(aspirin,patient_smith) & has_condition(patient_smith,aspirin) |- prescribed(aspirin)
------------------------------------------------------------
STDERR: Parse error: Unexpected token: exists

RETURN CODE: 1


================================================================================
 ACrQ Paraconsistent Examples
================================================================================

------------------------------------------------------------
Test: Basic bilateral predicate (transparent mode)
Command: wkrq --mode=acrq --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice)
    └──  1. T: Human(alice) [T-R: 0]


------------------------------------------------------------
Test: Explicit bilateral syntax
Command: wkrq --mode=acrq --syntax=bilateral --tree --show-rules Human*(alice)
------------------------------------------------------------
ACrQ Formula (bilateral mode): Human*(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human*(alice)
    └──  1. T: Human*(alice) [T-R*: 0]


------------------------------------------------------------
Test: Knowledge gap (N-sign)
Command: wkrq --mode=acrq --sign=N --tree --show-rules Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice)
Sign: N
Satisfiable: True

Tableau tree:
 0. N: Human(alice)
    ├──  1. F: Human(alice)  [N-R: 0]
    └──  2. F: Human*(alice) [N-R: 0]


------------------------------------------------------------
Test: Knowledge glut (paraconsistent contradiction)
Command: wkrq --mode=acrq --tree --show-rules Human(alice) & ~Human(alice)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice) & Human*(alice)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice) & Human*(alice)
    ├──  1. T: Human(alice)             [T-Conjunction: 0]
    │   └──  3. T: Human(alice)         [T-R: 1]
    └──  2. T: Human*(alice)            [T-Conjunction: 0]
        └──  4. T: Human*(alice)        [T-R*: 2]


------------------------------------------------------------
Test: No explosion from contradiction
Command: wkrq --mode=acrq --inference --countermodel --show-rules Human(alice) & ~Human(alice) |- Robot(bob)
------------------------------------------------------------
ACrQ Inference (transparent mode):
  Premises: Human(alice) & Human*(alice)
  Conclusion: Robot(bob)
  ✗ Invalid inference
  Countermodels:
    1. {Human(alice)=t, Human*(alice)=t, Robot(bob)=f}


================================================================================
 ACrQ Syntax Modes
================================================================================

------------------------------------------------------------
Test: Transparent mode (automatic conversion)
Command: wkrq --mode=acrq --syntax=transparent --tree --show-rules Human(alice) & ~Robot(bob)
------------------------------------------------------------
ACrQ Formula (transparent mode): Human(alice) & Robot*(bob)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice) & Robot*(bob)
    ├──  1. T: Human(alice)           [T-Conjunction: 0]
    │   └──  3. T: Human(alice)       [T-R: 1]
    └──  2. T: Robot*(bob)            [T-Conjunction: 0]
        └──  4. T: Robot*(bob)        [T-R*: 2]


------------------------------------------------------------
Test: Mixed mode (both syntaxes)
Command: wkrq --mode=acrq --syntax=mixed --tree --show-rules Human(alice) & Robot*(bob)
------------------------------------------------------------
ACrQ Formula (mixed mode): Human(alice) & Robot*(bob)
Sign: T
Satisfiable: True

Tableau tree:
 0. T: Human(alice) & Robot*(bob)
    ├──  1. T: Human(alice)           [T-Conjunction: 0]
    │   └──  3. T: Human(alice)       [T-R: 1]
    └──  2. T: Robot*(bob)            [T-Conjunction: 0]
        └──  4. T: Robot*(bob)        [T-R*: 2]


================================================================================
 Performance and Optimization Validation
================================================================================

------------------------------------------------------------
Test: Alpha rule prioritization (should be fast)
Command: wkrq --tree --show-rules ~(p & q) & (r | s)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: (~(p & q)) & (r | s)
    ├──  1. T: ~(p & q)         [T-Conjunction: 0]
    │   └──  3. F: p & q        [T-Negation: 1]
    │       ├──  4. F: p        [F-Conjunction: 3]
    │       └──  5. F: q        [F-Conjunction: 3]
    └──  2. T: r | s            [T-Conjunction: 0]
        ├──  6. T: r            [T-Disjunction: 2]
        ├──  7. T: s            [T-Disjunction: 2]
        ├──  8. T: r            [T-Disjunction: 2]
        └──  9. T: s            [T-Disjunction: 2]


------------------------------------------------------------
Test: Complex formula (branch selection test)
Command: wkrq --tree --show-rules (p | q) & (q | r) & (r | s) & (s | t)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: (((p | q) & (q | r)) & (r | s)) & (s | t)
    ├──  1. T: ((p | q) & (q | r)) & (r | s)         [T-Conjunction: 0]
    │   ├──  3. T: (p | q) & (q | r)                 [T-Conjunction: 1]
    │   │   ├──  5. T: p | q                         [T-Conjunction: 3]
    │   │   │   ├── 12. T: p                         [T-Disjunction: 5]
    │   │   │   ├── 13. T: q                         [T-Disjunction: 5]
    │   │   │   ├── 14. T: p                         [T-Disjunction: 5]
    │   │   │   ├── 15. T: q                         [T-Disjunction: 5]
    │   │   │   ├── 16. T: p                         [T-Disjunction: 5]
    │   │   │   ├── 17. T: q                         [T-Disjunction: 5]
    │   │   │   ├── 18. T: p                         [T-Disjunction: 5]
    │   │   │   └── 19. T: q                         [T-Disjunction: 5]
    │   │   └──  6. T: q | r                         [T-Conjunction: 3]
    │   │       ├── 20. T: q                         [T-Disjunction: 6]
    │   │       ├── 21. T: r                         [T-Disjunction: 6]
    │   │       └── 22. T: r                         [T-Disjunction: 6]
    │   └──  4. T: r | s                             [T-Conjunction: 1]
    │       ├──  9. T: r                             [T-Disjunction: 4]
    │       ├── 10. T: r                             [T-Disjunction: 4]
    │       └── 11. T: s                             [T-Disjunction: 4]
    └──  2. T: s | t                                 [T-Conjunction: 0]
        ├──  7. T: s                                 [T-Disjunction: 2]
        └──  8. T: t                                 [T-Disjunction: 2]


------------------------------------------------------------
Test: Early termination test
Command: wkrq --tree --show-rules p | q | r | s | t
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: (((p | q) | r) | s) | t
    ├──  1. T: ((p | q) | r) | s   [T-Disjunction: 0]
    └──  2. T: t                   [T-Disjunction: 0]


================================================================================
 Additional Unsatisfiable Cases (Closed Branch Demonstrations)
================================================================================

------------------------------------------------------------
Test: Simple contradiction (p and not p)
Command: wkrq --sign=T --tree --show-rules p & ~p
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: p & (~p)
    ├──  1. T: p  ×     [T-Conjunction: 0]
    └──  2. T: ~p       [T-Conjunction: 0]
        └──  3. F: p  × [T-Negation: 2]


------------------------------------------------------------
Test: Contradiction with disjunction
Command: wkrq --sign=T --tree --show-rules (p | q) & ~p & ~q
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ((p | q) & (~p)) & (~q)
    ├──  1. T: (p | q) & (~p)      [T-Conjunction: 0]
    │   ├──  4. T: p | q           [T-Conjunction: 1]
    │   │   ├──  7. T: p  ×        [T-Disjunction: 4]
    │   │   └──  8. T: q  ×        [T-Disjunction: 4]
    │   └──  5. T: ~p              [T-Conjunction: 1]
    │       └──  6. F: p  ×        [T-Negation: 5]
    └──  2. T: ~q                  [T-Conjunction: 0]
        └──  3. F: q  ×            [T-Negation: 2]


------------------------------------------------------------
Test: De Morgan's law contradiction
Command: wkrq --sign=T --tree --show-rules ~(p & q) & p & q
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ((~(p & q)) & p) & q
    ├──  1. T: (~(p & q)) & p   [T-Conjunction: 0]
    │   ├──  3. T: ~(p & q)     [T-Conjunction: 1]
    │   │   └──  5. F: p & q    [T-Negation: 3]
    │   │       ├──  6. F: p  × [F-Conjunction: 5]
    │   │       └──  7. F: q  × [F-Conjunction: 5]
    │   └──  4. T: p  ×         [T-Conjunction: 1]
    └──  2. T: q  ×             [T-Conjunction: 0]


------------------------------------------------------------
Test: Implication contradiction
Command: wkrq --sign=T --tree --show-rules (p -> q) & p & ~q
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ((p -> q) & p) & (~q)
    ├──  1. T: (p -> q) & p      [T-Conjunction: 0]
    │   ├──  4. T: p -> q        [T-Conjunction: 1]
    │   │   ├──  6. F: p  ×      [T-Implication: 4]
    │   │   └──  7. T: q  ×      [T-Implication: 4]
    │   └──  5. T: p  ×          [T-Conjunction: 1]
    └──  2. T: ~q                [T-Conjunction: 0]
        └──  3. F: q  ×          [T-Negation: 2]


------------------------------------------------------------
Test: Multiple variable contradiction
Command: wkrq --sign=T --tree --show-rules p & q & r & ~(p | q | r)
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ((p & q) & r) & (~((p | q) | r))
    ├──  1. T: (p & q) & r                  [T-Conjunction: 0]
    │   ├──  4. T: p & q                    [T-Conjunction: 1]
    │   │   ├──  6. T: p  ×                 [T-Conjunction: 4]
    │   │   └──  7. T: q  ×                 [T-Conjunction: 4]
    │   └──  5. T: r  ×                     [T-Conjunction: 1]
    └──  2. T: ~((p | q) | r)               [T-Conjunction: 0]
        └──  3. F: (p | q) | r              [T-Negation: 2]
            ├──  8. F: p | q  ×             [F-Disjunction: 3]
            └──  9. F: r  ×                 [F-Disjunction: 3]


------------------------------------------------------------
Test: Nested contradiction
Command: wkrq --sign=T --tree --show-rules ((p -> q) & (q -> r)) & p & ~r & q
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ((((p -> q) & (q -> r)) & p) & (~r)) & q
    ├──  1. T: (((p -> q) & (q -> r)) & p) & (~r)   [T-Conjunction: 0]
    │   ├──  3. T: ((p -> q) & (q -> r)) & p        [T-Conjunction: 1]
    │   │   ├──  6. T: (p -> q) & (q -> r)          [T-Conjunction: 3]
    │   │   │   ├──  8. T: p -> q                   [T-Conjunction: 6]
    │   │   │   │   └── 10. F: p  ×                 [T-Implication: 8]
    │   │   │   └──  9. T: q -> r                   [T-Conjunction: 6]
    │   │   │       ├── 11. F: q  ×                 [T-Implication: 9]
    │   │   │       └── 12. T: r  ×                 [T-Implication: 9]
    │   │   └──  7. T: p  ×                         [T-Conjunction: 3]
    │   └──  4. T: ~r                               [T-Conjunction: 1]
    │       └──  5. F: r  ×                         [T-Negation: 4]
    └──  2. T: q  ×                                 [T-Conjunction: 0]


------------------------------------------------------------
Test: Cannot be both true and false
Command: wkrq --sign=T --tree --show-rules (p -> q) & (~p -> q) & (p -> ~q) & (~p -> ~q)
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: (((p -> q) & ((~p) -> q)) & (p -> (~q))) & ((~p) -> (~q))
    ├──  1. T: ((p -> q) & ((~p) -> q)) & (p -> (~q))                [T-Conjunction: 0]
    │   ├──  3. T: (p -> q) & ((~p) -> q)                            [T-Conjunction: 1]
    │   │   ├──  5. T: p -> q                                        [T-Conjunction: 3]
    │   │   │   ├── 14. F: p  ×                                      [T-Implication: 5]
    │   │   │   ├── 15. T: q  ×                                      [T-Implication: 5]
    │   │   │   ├── 17. T: q  ×                                      [T-Implication: 5]
    │   │   │   ├── 22. F: p  ×                                      [T-Implication: 5]
    │   │   │   └── 23. T: q  ×                                      [T-Implication: 5]
    │   │   └──  6. T: (~p) -> q                                     [T-Conjunction: 3]
    │   │       ├── 18. F: ~p                                        [T-Implication: 6]
    │   │       │   └── 24. T: p  ×                                  [F-Negation: 18]
    │   │       ├── 19. T: q  ×                                      [T-Implication: 6]
    │   │       ├── 20. F: ~p                                        [T-Implication: 6]
    │   │       │   └── 25. T: p  ×                                  [F-Negation: 20]
    │   │       └── 21. T: q  ×                                      [T-Implication: 6]
    │   └──  4. T: p -> (~q)                                         [T-Conjunction: 1]
    │       ├── 11. F: p  ×                                          [T-Implication: 4]
    │       ├── 12. T: ~q                                            [T-Implication: 4]
    │       │   └── 16. F: q  ×                                      [T-Negation: 12]
    │       └── 13. F: p  ×                                          [T-Implication: 4]
    └──  2. T: (~p) -> (~q)                                          [T-Conjunction: 0]
        ├──  7. F: ~p                                                [T-Implication: 2]
        │   └──  9. T: p  ×                                          [F-Negation: 7]
        └──  8. T: ~q                                                [T-Implication: 2]
            └── 10. F: q  ×                                          [T-Negation: 8]


------------------------------------------------------------
Test: Quantifier contradiction
Command: wkrq --sign=T --tree --show-rules [forall X P(X)]Q(X) & P(a) & ~Q(a)
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: ([∀X P(X)]Q(X) & P(a)) & (~Q(a))
    ├──  1. T: [∀X P(X)]Q(X) & P(a)         [T-Conjunction: 0]
    │   ├──  4. T: [∀X P(X)]Q(X)            [T-Conjunction: 1]
    │   │   ├──  6. F: P(a)  ×              [T-RestrictedForall: 4]
    │   │   └──  7. T: Q(a)  ×              [T-RestrictedForall: 4]
    │   └──  5. T: P(a)  ×                  [T-Conjunction: 1]
    └──  2. T: ~Q(a)                        [T-Conjunction: 0]
        └──  3. F: Q(a)  ×                  [T-Negation: 2]


------------------------------------------------------------
Test: Mixed quantifier contradiction
Command: wkrq --sign=T --tree --show-rules [forall X P(X)]Q(X) & [exists Y P(Y)]~Q(Y)
------------------------------------------------------------
STDERR: Parse error: Unexpected token: Q(Y)

RETURN CODE: 1


------------------------------------------------------------
Test: Complex propositional unsatisfiable
Command: wkrq --sign=T --tree --show-rules ((p | q) -> r) & ((~p | ~q) -> r) & p & q & ~r
------------------------------------------------------------
Satisfiable: False

Tableau tree:
 0. T: (((((p | q) -> r) & (((~p) | (~q)) -> r)) & p) & q) & (~r)
    ├──  1. T: ((((p | q) -> r) & (((~p) | (~q)) -> r)) & p) & q      [T-Conjunction: 0]
    │   ├──  4. T: (((p | q) -> r) & (((~p) | (~q)) -> r)) & p        [T-Conjunction: 1]
    │   │   ├──  6. T: ((p | q) -> r) & (((~p) | (~q)) -> r)          [T-Conjunction: 4]
    │   │   │   ├──  8. T: (p | q) -> r                               [T-Conjunction: 6]
    │   │   │   │   ├── 10. F: p | q                                  [T-Implication: 8]
    │   │   │   │   │   └── 12. F: p  ×                               [F-Disjunction: 10]
    │   │   │   │   └── 11. T: r  ×                                   [T-Implication: 8]
    │   │   │   └──  9. T: ((~p) | (~q)) -> r  ×                      [T-Conjunction: 6]
    │   │   └──  7. T: p  ×                                           [T-Conjunction: 4]
    │   └──  5. T: q  ×                                               [T-Conjunction: 1]
    └──  2. T: ~r                                                     [T-Conjunction: 0]
        └──  3. F: r  ×                                               [T-Negation: 2]


================================================================================
 Edge Cases and Error Handling
================================================================================

------------------------------------------------------------
Test: Invalid syntax (should show error)
Command: wkrq --tree --show-rules p &
------------------------------------------------------------
STDERR: Parse error: Expected formula

RETURN CODE: 1


------------------------------------------------------------
Test: Mixed quantifier syntax
Command: wkrq --tree --show-rules [∀X Human(X)]Mortal(X) & [exists Y Student(Y)]Smart(Y)
------------------------------------------------------------
Satisfiable: True

Tableau tree:
 0. T: [∀X Human(X)]Mortal(X) & [∃Y Student(Y)]Smart(Y)
    ├──  1. T: [∀X Human(X)]Mortal(X)                       [T-Conjunction: 0]
    │   ├──  5. F: Human(c_3)                               [T-RestrictedForall: 1]
    │   └──  6. T: Mortal(c_3)                              [T-RestrictedForall: 1]
    └──  2. T: [∃Y Student(Y)]Smart(Y)                      [T-Conjunction: 0]
        ├──  3. T: Student(c_3)                             [T-RestrictedExists: 2]
        └──  4. T: Smart(c_3)                               [T-RestrictedExists: 2]


================================================================================
END OF VALIDATION TESTS
================================================================================
Review the output above to verify:
1. Tableau trees show correct rule application order
2. Alpha rules processed before beta rules
3. Valid inferences are recognized as valid
4. Invalid inferences show countermodels
5. ACrQ contradictions are satisfiable (paraconsistent)
6. Performance is reasonable (fast response times)
7. Error handling works for invalid syntax
